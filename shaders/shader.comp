#version 450

layout(binding = 0, rgba8_snorm) uniform writeonly image2D renderTarget;

layout(local_size_x = 16, local_size_y = 16) in;

// STRUCTS
struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitRecord {
    bool doesHit;
    float t;
    vec3 point;
    vec3 normal;
    bool frontFace;
};

struct Sphere {
    vec3 center;
    float radius;
};

// VARIABLES
Sphere sphere1 = Sphere(vec3(0.0f, 0.0f, 1.0f), 0.5f);


// METHODS
vec3 calculateRayColor(const Ray ray);
vec3 rayAt(const Ray ray, const float t);
HitRecord hitSphere(const Ray ray, const Sphere sphere);


// MAIN
void main() {
    const vec2 imageSize = vec2(imageSize(renderTarget));
    const vec2 uv = gl_GlobalInvocationID.xy / imageSize;

    const float viewportHeight = 2.0f;
    const float viewportWidth = imageSize.x / imageSize.y * viewportHeight;

    const vec3 origin = vec3(0.0f, 0.0f, 0.0f);
    const vec3 upperLeftCornerDirection = vec3(-viewportWidth / 2.0f, viewportHeight / 2.0f, 1.0f);

    Ray ray = Ray(origin, normalize(upperLeftCornerDirection + vec3(viewportWidth * uv.x, -viewportHeight * uv.y, 0.0f)));
    const vec3 pixelColor = calculateRayColor(ray);

    imageStore(renderTarget, ivec2(gl_GlobalInvocationID.xy), vec4(pixelColor, 1.0f));
}


// RENDERING
vec3 calculateRayColor(const Ray ray) {
    HitRecord record = hitSphere(ray, sphere1);
    if (record.doesHit) {
        return 0.5f * (record.normal + 1.0f);
    }

    const float t = (ray.direction.y + 1.0f) / 2.0f;
    return (1.0f - t) * vec3(1.0f, 1.0f, 1.0f) + t * vec3(0.5f, 0.7f, 1.0f);
}


// RAY
vec3 rayAt(const Ray ray, const float t) {
    return ray.origin + t * ray.direction;
}


// SPHERE
HitRecord hitSphere(const Ray ray, const Sphere sphere) {
    const vec3 CO = ray.origin - sphere.center;
    const float a = dot(ray.direction, ray.direction);
    const float halfB = dot(CO, ray.direction);
    const float c = dot(CO, CO) - sphere.radius * sphere.radius;

    const float D = halfB * halfB - a * c;

    if (D < 0) {
        return HitRecord(false, 0.0f, vec3(0.0f), vec3(0.0f), true);
    }

    const float t = (-halfB - sqrt(D)) / a;
    const vec3 point = rayAt(ray, t);

    const vec3 outwardNormal = normalize(point - sphere.center);
    const bool frontFace = dot(ray.direction, outwardNormal) < 0.0f;
    const vec3 normal = frontFace ? outwardNormal : -outwardNormal;

    return HitRecord(true, t, point, normal, frontFace);
}
