#version 450

layout(binding = 0, rgba8_snorm) uniform writeonly image2D renderTarget;

layout(local_size_x = 16, local_size_y = 16) in;

// STRUCTS
struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitRecord {
    bool doesHit;
    float t;
    vec3 point;
    vec3 normal;
    bool frontFace;
};

struct Sphere {
    vec3 center;
    float radius;
    uint material;
};

// ENUMS
const uint MATERIAL_DIFFUSE = 0;

// CONSTANTS
const float RENDER_DISTANCE = 100000000.0f;
const uint SAMPLES = 16384;
const uint MAX_DEPTH = 1024;
const vec3 BACKGROUND_COLOR = vec3(0.70f, 0.80f, 1.00f);

// VARIABLES
const uint spheresSize = 2;

Sphere spheres[spheresSize] = Sphere[spheresSize](
Sphere(vec3(0.0f, 0.0f, 1.0f), 0.5f, MATERIAL_DIFFUSE),
Sphere(vec3(0.0f, -100.5f, 1.0f), 100.0f, MATERIAL_DIFFUSE)
);


// METHODS
vec3 calculateRayColor(const Ray ray, const uint currentSample);
vec3 rayAt(const Ray ray, const float t);
HitRecord hitSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax);
HitRecord hitAnySphere(const Ray ray, const float tMin, const float tMax);
float random();
float randomInInterval(const float min, const float max);
vec3 randomVector(const float min, const float max);
vec3 randomUnitVector();


// MAIN
void main() {
    const vec2 imageSize = vec2(imageSize(renderTarget));

    const float viewportHeight = 2.0f;
    const float viewportWidth = imageSize.x / imageSize.y * viewportHeight;

    const vec3 origin = vec3(0.0f, 0.0f, 0.0f);
    const vec3 upperLeftCornerDirection = vec3(-viewportWidth / 2.0f, viewportHeight / 2.0f, 1.0f);

    vec3 summedPixelColor = vec3(0.0f);
    for (uint i = 0; i < SAMPLES; i++) {
        const float u = (gl_GlobalInvocationID.x + random()) / imageSize.x;
        const float v = (gl_GlobalInvocationID.y + random()) / imageSize.y;

        Ray ray = Ray(origin, normalize(upperLeftCornerDirection + vec3(viewportWidth * u, -viewportHeight * v, 0.0f)));
        summedPixelColor += calculateRayColor(ray, i);
    }

    const vec3 pixelColor = sqrt(summedPixelColor / float(SAMPLES));

    imageStore(renderTarget, ivec2(gl_GlobalInvocationID.xy), vec4(pixelColor, 1.0f));
}


// RENDERING
vec3 calculateRayColor(const Ray ray, const uint currentSample) {
    Ray currentRay = ray;
    vec3 currentColor = BACKGROUND_COLOR;

    for (uint depth = 0; depth < MAX_DEPTH; depth++) {
        HitRecord record = hitAnySphere(currentRay, 0.001f, RENDER_DISTANCE);

        if (!record.doesHit) {
            break;
        }

        currentColor = 0.5f * currentColor;
        currentRay = Ray(record.point, record.normal + randomUnitVector());
    }

    return currentColor;
}


// RAY
vec3 rayAt(const Ray ray, const float t) {
    return ray.origin + t * ray.direction;
}


// SPHERE
HitRecord hitSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {
    const vec3 CO = ray.origin - sphere.center;
    const float a = dot(ray.direction, ray.direction);
    const float halfB = dot(CO, ray.direction);
    const float c = dot(CO, CO) - sphere.radius * sphere.radius;

    const float D = halfB * halfB - a * c;

    if (D < 0) {
        return HitRecord(false, 0.0f, vec3(0.0f), vec3(0.0f), true);
    }

    const float t1 = (-halfB - sqrt(D)) / a;
    const float t2 = (-halfB + sqrt(D)) / a;

    float t;

    if (t1 >= tMin && t1 <= tMax) {
        t = t1;
    } else if (t2 >= tMin && t2 <= tMax) {
        t = t2;
    } else {
        return HitRecord(false, 0.0f, vec3(0.0f), vec3(0.0f), true);
    }

    const vec3 point = rayAt(ray, t);
    const vec3 outwardNormal = normalize(point - sphere.center);
    const bool frontFace = dot(ray.direction, outwardNormal) < 0.0f;
    const vec3 normal = frontFace ? outwardNormal : -outwardNormal;

    return HitRecord(true, t, point, normal, frontFace);
}

HitRecord hitAnySphere(const Ray ray, const float tMin, const float tMax) {
    HitRecord record = HitRecord(false, tMax, vec3(0.0f), vec3(0.0f), true);

    for (uint i = 0; i < spheresSize; i++) {
        HitRecord tempRecord = hitSphere(ray, spheres[i], tMin, record.t);
        if (tempRecord.doesHit) {
            record = tempRecord;
        }
    }

    return record;
}


// RANDOM
uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >>  6u);
    x += (x <<  3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

uint currentRandomOffset = 0;

float random() {
    currentRandomOffset += 1;
    const uvec3 v = floatBitsToUint(vec3(gl_GlobalInvocationID.xy, currentRandomOffset));

    uint m = hash(v.x ^ hash(v.y) ^ hash(v.z));
    m &= 0x007FFFFFu;
    m |= 0x3F800000u;
    return uintBitsToFloat(m) - 1.0f;
}

float randomInInterval(const float min, const float max) {
    return random() * (max - min) + min;
}

vec3 randomVector(const float min, const float max) {
    return vec3(randomInInterval(min, max), randomInInterval(min, max), randomInInterval(min, max));
}

vec3 randomUnitVector() {
    return normalize(randomVector(-1.0f, 1.0f));
}
